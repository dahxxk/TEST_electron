{"version":3,"sources":["webpack:///webpack/bootstrap 565ce52b3c67ee413d65?95ae*","webpack:///external \"electron\"?6928*","webpack:///./src/renderer/captureWindow.js"],"names":["getDesktopVideoStream","sourceDisplay","Promise","resolve","reject","desktopCapturer","getSources","types","error","sources","targetSource","length","find","source","name","message","navigator","webkitGetUserMedia","audio","video","mandatory","chromeMediaSource","chromeMediaSourceId","id","minWidth","minHeight","maxWidth","maxHeight","getCaptureImage","videoElement","trimmedBounds","videoWidth","videoHeight","s","scaleFactor","blankWidth","Math","max","bounds","width","blankHeight","height","offsetX","x","offsetY","y","canvasElement","document","createElement","context","getContext","drawImage","toDataURL","ipcRenderer","on","_","then","src","URL","createObjectURL","stream","play","addEventListener","dataURL","send","pause","revokeObjectURL","catch"],"mappings":"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","file":"dist/renderer/captureWindow.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 192);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 565ce52b3c67ee413d65","module.exports = require(\"electron\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"electron\"\n// module id = 12\n// module chunks = 0 1 2","import { ipcRenderer, desktopCapturer } from \"electron\";\r\n\r\nfunction getDesktopVideoStream(sourceDisplay) {\r\n  return new Promise((resolve, reject) => {\r\n    desktopCapturer.getSources({ types: [\"screen\"] }, (error, sources) => {\r\n      if (error) {\r\n        return reject(error);\r\n      }\r\n      let targetSource;\r\n      if (sources.length === 1) {\r\n        targetSource = sources[0];\r\n      } else {\r\n        targetSource = sources.find(source => source.name === sourceDisplay.name);\r\n      }\r\n      if (!targetSource) {\r\n        return reject({ message: \"No available source\" });\r\n      }\r\n      // 스트림 객체 추출하기\r\n      navigator.webkitGetUserMedia({\r\n        audio: false,\r\n        video: {\r\n          mandatory: {\r\n            chromeMediaSource: \"desktop\",\r\n            chromeMediaSourceId: targetSource.id,\r\n            minWidth: 100,\r\n            minHeight: 100,\r\n            maxWidth: 4096,\r\n            maxHeight: 4096\r\n          }\r\n        }\r\n      },\r\n      resolve, reject);\r\n    });\r\n  });\r\n}\r\n\r\nfunction getCaptureImage({ videoElement, trimmedBounds, sourceDisplay }){\r\n  // video 요소의 너비와 높이 추출하기\r\n  const { videoWidth, videoHeight } = videoElement;\r\n\r\n  // 캡처 대상 스트림의 출력 배율 추출하기\r\n  const s = sourceDisplay.scaleFactor || 1;\r\n\r\n  // video 요소 내부의 데스크톱 이미지 여백 크기 산출하기\r\n  const blankWidth  = Math.max((videoWidth  - sourceDisplay.bounds.width  * s) / 2, 0);\r\n  const blankHeight = Math.max((videoHeight - sourceDisplay.bounds.height * s) / 2, 0);\r\n\r\n  // video 요소 내부의 대상 영역의 위치(x/y 좌표) 산출하기\r\n  const offsetX = (trimmedBounds.x - sourceDisplay.bounds.x) * s + blankWidth;\r\n  const offsetY = (trimmedBounds.y - sourceDisplay.bounds.y) * s + blankHeight;\r\n\r\n  // canvas 요소 만들기\r\n  const canvasElement = document.createElement(\"canvas\");\r\n  const context = canvasElement.getContext(\"2d\");\r\n\r\n  // 자를 대상 영역의 너비와 높이를 canvas 요소에 설정하기\r\n  canvasElement.width  = trimmedBounds.width;\r\n  canvasElement.height = trimmedBounds.height;\r\n\r\n  // canvas 요소에 video 요소의 내용 렌더링하기\r\n  context.drawImage(\r\n    videoElement,\r\n    offsetX, offsetY, trimmedBounds.width * s, trimmedBounds.height * s,\r\n    0, 0, trimmedBounds.width, trimmedBounds.height\r\n  );\r\n\r\n  // canvas 요소에서 이미지 데이터 추출하기\r\n  return canvasElement.toDataURL(\"image/png\");\r\n}\r\n\r\nipcRenderer.on(\"CAPTURE\", (_, { sourceDisplay, trimmedBounds }) => {\r\n  getDesktopVideoStream(sourceDisplay).then(stream => {\r\n    // 추출한 스트림을 객체 URL로 변환하기\r\n    const videoElement = document.createElement(\"video\");\r\n    videoElement.src= URL.createObjectURL(stream);\r\n    videoElement.play();\r\n    videoElement.addEventListener(\"loadedmetadata\", () => {\r\n      // video 요소에서 이미지 데이터 추출하기\r\n      const dataURL = getCaptureImage({ videoElement, trimmedBounds, sourceDisplay });\r\n      // Main 프로세스로 이미지 데이터 전송하기\r\n      ipcRenderer.send(\"REPLY_CAPTURE\", { dataURL });\r\n      videoElement.pause();\r\n      // 객체 URL 파기하기\r\n      URL.revokeObjectURL(dataURL);\r\n    });\r\n  }).catch(error => {\r\n    ipcRenderer.send(\"REPLY_CAPTURE\", { error });\r\n  });\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer/captureWindow.js"],"sourceRoot":""}